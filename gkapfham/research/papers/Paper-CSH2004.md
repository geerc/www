---
id: -9 
title: Software Testing 
layout: researchpaper_n
categories: [research, chapter, book, testing]
authors: Gregory M. Kapfhammer
mapped: true 
header: false 
research: false 
paper: true
backup: ../../../../../../
---

## {{ page.title }} [<i class="fa fa-download"></i>]({{site.baseurl}}download/research/papers/csh2004-kapfhammer.pdf "Download this Paper!")

### {{page.authors }}

### <em>The Computer Science Handbook</em>, June 2004

### Abstract

When a program is implemented to provide a concrete representation of an algorithm, the developers of this program are
naturally concerned with the correctness and performance of the implementation. Software engineers must ensure that
their software systems achieve an appropriate level of quality. Software verification is the process of ensuring that a
program meets its intended specification. One technique that can assist during the specification, design, and
implementation of a software system is software verification through correctness proof. Software testing, or the process
of assessing the functionality and correctness of a program through execution or analysis, is an another alternative for
verifying a software system.As noted by Bowen, Hinchley, and Geller, software testing can be appropriately used in
conjunction with correctness proofs and other types of formal approaches in order to develop high quality software
systems. Yet, it is also possible to use software testing techniques in isolation from program correctness proofs or
other formal methods. 

Software testing is not a "silver bullet" that can guarantee the production of high quality software systems. While a
"correct" correctness proof demonstrates that a software system (which exactly meets its specification) will always
operate in a given manner, software testing that is not fully exhaustive can only suggest the presence of flaws and
cannot prove their absence. Moreover, Kaner et al. have noted that it is impossible to completely test an application
because: (1) the domain of program inputs is too large, (2) there are too many possible input paths, and (3) design and
specification issues are difficult to test. The first and second points present obvious complications and the final
point highlights the difficulty of determining if the specification of a problem solution and the design of its
implementation are also correct.
